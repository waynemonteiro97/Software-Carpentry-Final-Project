'''
Grid Solver Class
Author: Prabhjot Kaur
This code provides the shortest path between the
start point and the end points so given using Breadh For Search
Algorithm in the grid (like we did for maze!). Unlike in the maze
solver which uses stacks which follows LIFO system, here we use queues
which follow the FIFO system and inherently provides us with the shortest
path to reach all the end points.
For example, lets consider a maze
1 0 0 1
1 1 0 1
0 1 1 1
start point is (0, 0)
end point is (0, 3)
Through BFS algorithm we can draw something like a binary tree
                           (0, 0) - -start point
                    (1, 0)        (1, 1)
                (1, 1)   (2, 1) (2, 1) (2, 2)
            (2, 1) (2, 2)  (2, 2) (2, 2)  (2, 3)
           ..................................(1, 3)
        .......................................(0, 3) -- final end point
To avoid these repetitions we create a copy of this grid in which the points
which are visited are switched from 0 to 1, once we get an array of the order
of the  points so visted we can find the path by retracing from end point to
start point.
There are couple of errors which come up while using queues and hence these
additional fnctions are created to tackle such errors
Here we find the shortest distance between the start and one of the end points
which is reached first then that becomes your new origin or start point
in the main solver where this code is imported a loop is carried out till all
the end points are reached
'''
import queue
import sys
import copy

WALL = 0
PATH = 1
VALID_PATH = 2
INVALID_PATH = 3
ENDPOINT = 4
INTMAX = sys.maxsize - 1


class Grid:
    '''
    Consists of function to solve the grid
    i.e find the shortest path from origin to
    multiple drop points
    Uses Breadth for Search Algorithm, hence uses queues (FIFO)
    '''

    def __init__(self, grid, start_pt, end_pt):
        '''
        Initialises the Class Object
        ** Parameters **
        self : Object of Class
        grid : List of Lists : *int*
              Grid so generated by converting the Google Image
        start_pt : *tuple* : *int*
             Start point so selected by the user
        end_pt : List of tuples : *int*
             List of all the end points selected by the user

        ** Returns **
        Nothing!
        '''
        self.grid = grid
        self.h = len(grid)
        self.w = len(grid[0])
        self.follow = queue.Queue(INTMAX)
        self.path = queue.Queue(INTMAX)
        self.start = start_pt
        self.end = end_pt

    def valid_point(self, coord, height, width):
        '''
        This function checks if the given point is within
        the grid or not, thus valid or not

        ** Parameters **
        coord : List/Tuple : *int*
               The point coordinates
        height : *int*
                Height of the grid generated from the image
        width : *int*
                Width of the grid generated from the image

        ** Returns **
        True or False : *Bool*
        '''
        x = coord[0]
        y = coord[1]
        if x >= 0 and y >= 0 and x < height and y < width:
            return True
        else:
            return False

    def mod_finalpath(self, end_pt):
        '''
        One of the errors to find the solution path is if the last
        point in the queue is not the end point. This is then modifies the
        first part of the solution path for its last point to be the end point

        ** Parameters **
        end_pt : List of tuples : *int*
               End point List

        ** Returns **
        final_path : first part of the modified solution path
        '''
        for ele in list(reversed(self.follow.queue)):
            if ele in end_pt:
                index = list(self.follow.queue).index(ele)
                break

        final_path = [list(self.follow.queue)[index]]
        n = len(list(self.follow.queue))

        for i in range(n, -1, index + 1):
            final_path.append(list(self.follow.queue)[i])

        return(final_path)

    def shortest_path(self):
        '''
        This function uses the Breadth for Search Algorithm
        for finding the shortest path between two points.
        Uses queues which uses FIFO.

        ** Parameters **
        None

        ** Returns **
        new_origin : Tuple : *int*
                    The end point so reached which becomes the
                     start point
        final_path : List of tuples : *int*
                   The final path so followed between the 2 points
        '''
        possible_coord = [(-1, 0), (0, -1), (1, 0), (0, 1)]
        visited_grid = [[False for j in range(self.w)] for i in range(self.h)]
        end_pt = copy.deepcopy(self.end)

        # if the start and the end points are not a valid path
        if self.grid[self.start[0]][self.start[1]] != 1:
            for ele in self.end:
                if self.grid[ele[0]][ele[1]] != 1:
                    return -1

        # Start point is now visited
        visited_grid[self.start[0]][self.start[1]] = True
        self.path.put(self.start)
        new_origin = None

        # Looping through the VALID PATH
        while len(list(self.path.queue)) != 0:
            # accessing the first element of queue
            current_pos = self.path.queue[0]
            if current_pos in self.end:
                if current_pos not in self.follow.queue:
                    self.follow.put(current_pos)
                self.end.pop(self.end.index(current_pos))
                new_origin = current_pos
                break
            else:
                self.path.get()
                for i in range(len(possible_coord)):
                    next_x = current_pos[0] + possible_coord[i][0]
                    next_y = current_pos[1] + possible_coord[i][1]
                    if self.valid_point((next_x, next_y), self.h, self.w) and visited_grid[next_x][next_y] == False and self.grid[next_x][next_y] == 1:
                        visited_grid[next_x][next_y] = True
                        self.path.put((next_x, next_y))
                        if current_pos not in self.follow.queue:
                            self.follow.put(current_pos)

        final_path = [list(self.follow.queue)[-1]]
        counter = 0
        if final_path[-1] not in end_pt:
            final_path = self.mod_finalpath(end_pt)

        for i, ele in enumerate(reversed(list(self.follow.queue))):
            x = ele[0]
            y = ele[1]
            last_pos = final_path[counter]
            if ele not in final_path and (x == last_pos[0] and (y == last_pos[1] + 1 or y == last_pos[1] - 1)) or (y == last_pos[1] and (x == last_pos[0] + 1 or x == last_pos[0] - 1)):
                final_path.append(ele)
                counter += 1

        return(new_origin, final_path)


if __name__ == "__main__":
    pass
